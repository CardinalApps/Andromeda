/**
 * @module
 */

/**
 * The Bridge allows for the client to communicate with the Hydra server, if it
 * exists on the LAN. The Bridge supports the server HTTP API, and the server
 * WebSocket API.
 *
 * When running in Electron, the Bridge can also be used to communicate with the
 * Electron main process via IPC, regardless of whether there is a server
 * available.
 *
 * After creating a Bridge instance, call `init()` for each connection type you
 * wish to establish.
 */
 export class Bridge {
  constructor() {
    this.appDebug = 1 // the rest of the app can check this
    this.consoleColor = '#1ba801'

    this.ipcListeners = {}
    this._listenerForwarders = {}
    this.wsListeners = {}
    this._wsListenerForwarders = {}

    this.ipcConnectionEstablished = false
    this.httpConnectionEstablished = false
    this.wsConnectionEstablished = false
  }

  /**
   * Invoked by the theme, this will retrieve information needed for this Bridge
   * instance. Must be invoked before the Bridge can be used normally.
   *
   * @param {string} type - Connection type. `http` for the HTTP API, `ws` for
   * the WebSocket API, or `ipc` for Electron IPC.
   * @param {object} [options] - Required for `http` and `ws` connections, this
   * must be an object with the properties `scheme`, `host`, and `port`.
   * @returns {boolean} Returns a boolean indicating whether the connection was
   * established.
   */
  async init(type, options) {
    if (type === 'ipc') {
      return await this._initIpc()
    } else if (type === 'http') {
      return await this._initHttp(options)
    } else if (type === 'ws') {
      return await this._initWs(options)
    } else {
      throw new Error(`Unrecognized connection type "${type}"`)
    }
  }

  /**
   * IPC counterpart to the `init()` method.
   * 
   * @ignore
   */
  async _initIpc() {
    if (typeof require !== 'function') {
      this.env = 'web'
      this.ipcConnectionEstablished = false
      return false
    }

    try {
      this.env = 'web'
      this.electronIpc = require('electron').ipcRenderer
    } catch (error) {
      this.ipcConnectionEstablished = false
      return false
    }

    let ipcStatus = await this.ipcAsk('status')

    if (ipcStatus === 200) {
      this.env = 'electron'
      this.ipcConnectionEstablished = true
      console.log(`%cEstablished connection to Electron via IPC`, `color:${this.consoleColor};`)
      return true
    } else {
      console.error('Could not communicate with the Electron main process over IPC')
      return false
    }
  }

  /**
   * Checks if the HTTP API is available on the local network.
   * 
   * @ignore
   */
  async _initHttp(options) {
    if (!('scheme' in options)) throw new Error('HTTP Bridge connection requires options.scheme')
    if (!('host' in options)) throw new Error('HTTP Bridge connection requires options.host')
    if (!('port' in options)) throw new Error('HTTP Bridge connection requires options.port')
      
    this.httpServer = options

    // try to connect to the status page
    let statusResponse = await this.httpApi('/status')

    if (statusResponse.status === 200) {
      this.httpConnectionEstablished = true
      console.log(`%cEstablished connection to HTTP server`, `color:${this.consoleColor};`)
      return true
    } else {
      console.error('Server did not return status 200')
      return false
    }
  }

  /**
   * WebSocket counterpart to the `init()` method.
   * 
   * @ignore
   */
  async _initWs(options) {
    if (!('scheme' in options)) throw new Error('WebSocket Bridge connection requires options.scheme')
    if (!('host' in options)) throw new Error('WebSocket Bridge connection requires options.host')
    if (!('port' in options)) throw new Error('WebSocket Bridge connection requires options.port')
    
    this.wsServer = options
    const wsBaseUrl = `${this.wsServer.scheme}${this.wsServer.host}:${this.wsServer.port}`
        
    // connects to the WebSocket server and waits for a connection ID to be returned
    const connect = (cb) => {
      this.BridgeWebSocket = new WebSocket(`${wsBaseUrl}/bridge?app=music`)
      
      this.BridgeWebSocket.addEventListener('open', (event) => {
        cb()
      })
      
      this.BridgeWebSocket.addEventListener('message', (event) => {
        let data = JSON.parse(event.data)
        let channel = data.channel
        let message = data.message
        
        // the ws server always immediately sends back the connection ID when a
        // new connection is established
        if (channel === 'connection-id') {
          if (!('connectionId' in this.wsServer)) {
            this.wsServer.connectionId = message
          } else {
            console.warn('Why is this connection receiving another connectionId?')
          }
        }

        console.log(`Bridge received WebSocket message on channel ${channel}`, message)

        // forward the message to channel listeners
        if (channel in this.wsListeners && Array.isArray(this.wsListeners[channel])) {
          for (let cb of this.wsListeners[channel]) {
            cb(message)
          }
        }
      })

      this.BridgeWebSocket.addEventListener('error', (event) => {
        console.error('WebSocket error event', event)
        cb(true)
      })

      this.BridgeWebSocket.addEventListener('close', (event) => {
        console.log(`%cWebSocket connection closed`, `color:${this.consoleColor};`)
      })
    }

    // this promise will resolve when either a websocket connection is
    // established, or the timer runs out
    return new Promise((resolve, reject) => {
      let connectionFailedBeforeTimeout = false
      let connected = false
      let timedOut = false

      // if the timer runs out and the connection has not happened yet, resolve
      // the promise to false
      setTimeout(() => {
        if (connected || connectionFailedBeforeTimeout) return
        console.warn('WebSocket connection timed out while trying to establish initial connection')
        timedOut = true
        resolve(false)
      }, 2000)

      // when the connection is established, resolve the promise to true
      connect((connectionFailed) => {
        if (timedOut) return

        if (connectionFailed) {
          connectionFailedBeforeTimeout = true
          return resolve(false)
        }

        connected = true
        this.wsConnectionEstablished = true

        console.log(`%cEstablished connection to WebSocket server`, `color:${this.consoleColor};`)

        resolve(true)
      })
    })
  }

  /**
   * Sends an IPC message on a channel. Does not expect a response.
   * 
   * @param {string} channel - IPC channel name.
   * @param {*} message - Message to send. Strings, array, object, boolean, number.
   */
  ipcSay(channel, message) {
    this.electronIpc.send(channel, message)
  }

  /**
   * Same as `.say()`, except that it expects a response.
   * 
   * @param {string} channel - IPC channel name.
   * @param {*} message - Message to send. Strings, array, object, boolean, number.
   * @returns {Promise} A promise that resolves with the reply from the main process.
   */
  ipcAsk(channel, message) {
    return new Promise((resolve, reject) => {
      this.electronIpc.invoke(channel, message).then((reply) => {
        resolve(reply)
      })
    })
  }

  /**
   * Registers a listener on an IPC channel. If an IPC listener is registered
   * when running on the web, the callback will simply never be triggered.
   *
   * @param {string} channel - IPC channel name.
   * @param {Function} cb - Callback function invoked whenever something is said
   * on the channel.
   */
  ipcListen(channel, cb) {
    // disable IPC listeners when not running in Electron
    if (this.env !== 'electron') return

    // create the channel array of callbacks if it doesn't exist in the Bridge
    if (!(channel in this.ipcListeners)) {
      this.ipcListeners[channel] = []
    }

    // save the callback in the Bridge
    this.ipcListeners[channel].push(cb)

    // check if the Bridge already registered the forwarder-listener for this channel
    if (this.electronIpc.rawListeners(channel).length) {
      return
    }

    function listenerForwarder(event, arg) {
      if (Array.isArray(this.ipcListeners[channel])) {
        for (let savedCb of this.ipcListeners[channel]) {
          savedCb(arg, event)
        }
      } else {
        console.warn(`Tried to trigger callbacks for ipc channel '${channel}' but no callbacks were registered. Should there still be an ipc forwarder for this event?`)
        console.log(channel)
        console.log(cb)
      }
    }

    // bind the save the forwarder internally
    this._listenerForwarders[channel] = listenerForwarder.bind(this)

    // register the forwarder
    this.electronIpc.on(channel, this._listenerForwarders[channel])
  }

  /**
   * Returns the HTTP API URL for the connected Cardinal Server.
   */
  httpApiUrl() {
    return `${this.httpServer.scheme}${this.httpServer.host}:${this.httpServer.port}/api`
  }

  /**
   * Sends a HTTP request to the local Hydra server.
   *
   * @param {string} route - The route for this endpoint in the Hydra Server
   * API. Must contain a leading slash.
   * @param {string} verb - HTTP request method.
   * @param {*} body - Request body. Will be automatically stringified if
   * necessary.
   * @returns {object} Returns a response object, which contains the parsed
   * server response and a status code.
   */
  httpApi(route, verb = 'GET', body = null) {
    return new Promise((resolve, reject) => {
      let url = `${this.httpApiUrl()}${route}`
      let req = new XMLHttpRequest()

      req.addEventListener('error', () => {
        reject()
      })

      req.addEventListener('load', function loaded(progEvent) {
        let responseObject = {
          'status': this.status,
          'statusRange': Number(this.status.toString()[0]), // response range, eg 2 for 2xx, 3 for 3xx, etc
          'response': '(Unparsed)', // if not overwritten by the time it's returned, something went wrong
          'event': this
        }

        try {
          responseObject.response = JSON.parse(this.response)
        } catch (parseError) {
          // catching a parse error means it's not JSON, so return the raw data
          responseObject.response = this.response
        }

        resolve(responseObject)
      })

      if (typeof body === 'object' && body !== null) {
        body = JSON.stringify(body)
      }

      req.open(verb, url)
      req.send(body)
    })
  }

  /**
   * Returns the HTTP URL for static files on the connected Cardinal Server.
   */
  httpStaticUrl() {
    return `${this.httpServer.scheme}${this.httpServer.host}:${this.httpServer.port}`
  }

  /**
   * Gets a static file from the server.
   *
   * @param {string} path - Relative path to the file from the server location.
   * Must contain a leading slash.
   * @returns {object|string} Returns the raw contents of the URL, unless it
   * returns a JSON-like string, in which it will be parsed. Or throws an error
   * if something went wrong.
   */
  httpStatic(path) {
    return new Promise((resolve, reject) => {
      let url = `${this.httpStaticUrl()}${path}`
      let req = new XMLHttpRequest()

      req.addEventListener('error', () => {
        reject('httpStatic() request error')
      })

      req.addEventListener('load', function loaded(progEvent) {
        if (this.status !== 200) {
          return reject('httpStatic() request status error')
        }

        let data

        try {
          data = JSON.parse(this.response)
        } catch (parseError) {
          // catching a parse error means it's not JSON, so return the raw data
          data = this.response
        }

        resolve(data)
      })

      req.open('GET', url)
      req.send()
    })
  }

  /**
   * Sends a message to the server via WebSockets. The WebSocket connect must
   * have already been established with init().
   * 
   * @param {string} channel - Anything that can be send by WebSocket.send().
   * @param {mixed} message - Anything that that be stringified.
   * @returns {boolean} Returns true if no errors were thrown. Returns false if
   * the connection had not been established.
   */
  wsSay(channel, message) {
    if (!this.wsConnectionEstablished) {
      console.error('No WebSocket Connection')
      return false
    }

    let payload = JSON.stringify({
      channel,
      message
    })

    try {
      this.BridgeWebSocket.send(payload)
    } catch (error) {
      console.error('Error sending WebSocket message')
      throw error
    }

    return true
  }

  /**
   * Subscribe to messages on a certain WebSocket channel. This type of listener j
   * 
   * @param {string} channel - WebSocket channel name.
   * @param {Function} cb - Callback function invoked whenever something is said on the channel.
   */
  async wsListen(channel, cb) {
    // create the channel array of callbacks if it doesn't exist
    if (!(channel in this.wsListeners)) {
      this.wsListeners[channel] = []
    }

    // save the channel name on the server side of the connection
    await this.wsSay('add-channel', channel)

    // save the callback in the Bridge
    this.wsListeners[channel].push(cb)
  }

  /**
   * Removes an IPC or WS listener.
   * 
   * @param {string} channel - Channel name.
   * @param {Function} cb - Reference to the callback function.
   * @param {Function} ws - Remove a WebSocket listener instead of an IPC one.
   * @returns {boolean}
   */
  removeListener(channel, cb, ws = false) {
    if (ws) {
      this.removeWsListener(channel, cb)
    } else {
      this.removeIpcListener(channel, cb)
    }

    return true
  }

  /**
   * Removes an IPC listener.
   */
  removeIpcListener(channel, cb) {
    if (this.env !== 'electron') return

    if (!(channel in this.ipcListeners)) {
      console.trace(`Trying to remove IPC listener that does not exist: ${channel}. This can happen if a custom element did not fully execute its connectedCallback() before its disconnectedCallback() was invoked. If it happens regularily, it's probably an extra Bridge.removeListener().`)
      return
    }

    // remove this particular callback function
    for (let index in this.ipcListeners[channel]) {
      if (this.ipcListeners[channel][index] === cb) {
        this.ipcListeners[channel].splice(index, 1)
      }
    }

    // if there are no more callback functions for this channel, delete the channel
    if (!this.ipcListeners[channel].length) {
      delete this.ipcListeners[channel]
      this.electronIpc.removeListener(channel, this._listenerForwarders[channel])
    }
  }

  /**
   * Removes an WebSocket listener.
   */
  removeWsListener(channel, cb) {
    if (!(channel in this.wsListeners)) {
      console.warn(`Trying to remove WS listener that does not exist: ${channel}. This can happen if a custom element did not fully execute its connectedCallback() before its disconnectedCallback() was invoked. If it happens regularily, it's probably an extra Bridge.removeListener().`)
      return
    }

    // remove this particular callback function
    for (let index in this.wsListeners[channel]) {
      if (this.wsListeners[channel][index] === cb) {
        this.wsListeners[channel].splice(index, 1)
      }
    }

    // if there are no more callback functions for this channel, delete the channel
    if (!this.wsListeners[channel].length) {
      delete this.wsListeners[channel]
    }

    // TODO need to remove the listener from the server WebSocket too
  }

  /**
   * console.log's the raw ipc listeners for a channel. For use in the renderer dev tools.
   * 
   * @param {string} channel - IPC channel name.
   */
  __showListeners(channel) {
    console.log(this.electronIpc.rawListeners(channel))
  }

  /**
   * Removes all IPC and WS listeners. Does not close the WS connection.
   */
  cleanup() {
    this.electronIpc.removeAllListeners()

    this.ipcListeners = {}
    this._listenerForwarders = {}
    this.wsListeners = {}
    this._wsListenerForwarders = {}
  }
}